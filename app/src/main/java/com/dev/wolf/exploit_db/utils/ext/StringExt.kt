package com.dev.wolf.exploit_db.utils.ext

import android.net.Uri
import android.text.Spanned
import androidx.collection.arraySetOf
import androidx.core.text.HtmlCompat
import java.math.BigInteger
import java.net.URLEncoder
import java.security.MessageDigest
import java.text.SimpleDateFormat
import java.util.*
import com.dev.wolf.exploit_db.R
import kotlin.contracts.contract
import kotlin.math.min

fun String.longHashCode(): Long {
    var h = 1125899906842597L
    val len: Int = this.length
    for (i in 0 until len) {
        h = 31 * h + this[i].code.toLong()
    }
    return h
}

fun String.removeSurrounding(vararg chars: Char): String {
    if (length == 0) {
        return this
    }
    for (c in chars) {
        if (first() == c && last() == c) {
            return substring(1, length - 1)
        }
    }
    return this
}

fun String.toCamelCase(): String {
    if (isEmpty()) {
        return this
    }
    val result = StringBuilder(length)
    var capitalize = true
    for (char in this) {
        result.append(
            if (capitalize) {
                char.uppercase()
            } else {
                char.lowercase()
            }
        )
        capitalize = char.isWhitespace()
    }
    return result.toString()
}

fun String.transliterate(skipMissing: Boolean): String {
    val cyr = charArrayOf(
        'а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п',
        'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'ё', 'ў'
    )
    val lat = arrayOf(
        "a", "b", "v", "g", "d", "e", "zh", "z", "i", "y", "k", "l", "m", "n", "o", "p",
        "r", "s", "t", "u", "f", "h", "ts", "ch", "sh", "sch", "", "i", "", "e", "ju", "ja", "jo", "w"
    )
    return buildString(length + 5) {
        for (c in this@transliterate) {
            val p = cyr.binarySearch(c.lowercaseChar())
            if (p in lat.indices) {
                if (c.isUpperCase()) {
                    append(lat[p].uppercase())
                } else {
                    append(lat[p])
                }
            } else if (!skipMissing) {
                append(c)
            }
        }
    }
}

fun String.toFileNameSafe() = this.transliterate(false)
    .replace(Regex("[^a-z0-9_\\-]", arraySetOf(RegexOption.IGNORE_CASE)), " ")
    .replace(Regex("\\s+"), "_")

fun String.ellipsize(maxLength: Int) = if (this.length > maxLength) {
    this.take(maxLength - 1) + Typography.ellipsis
} else this

fun String.splitTwoParts(delimiter: Char): Pair<String, String>? {
    val indices = ArrayList<Int>(4)
    for ((i, c) in this.withIndex()) {
        if (c == delimiter) {
            indices += i
        }
    }
    if (indices.isEmpty() || indices.size and 1 == 0) {
        return null
    }
    val index = indices[indices.size / 2]
    return substring(0, index) to substring(index + 1)
}

fun String.urlEncoded(): String = URLEncoder.encode(this, Charsets.UTF_8.name())

fun String.toUriOrNull(): Uri? = if (isEmpty()) {
    null
} else {
    Uri.parse(this)
}

fun ByteArray.byte2HexFormatted(): String {
    val str = StringBuilder(size * 2)
    for (i in indices) {
        var h = Integer.toHexString(this[i].toInt())
        val l = h.length
        if (l == 1) {
            h = "0$h"
        }
        if (l > 2) {
            h = h.substring(l - 2, l)
        }
        str.append(h.uppercase(Locale.ROOT))
        if (i < size - 1) {
            str.append(':')
        }
    }
    return str.toString()
}

fun String.md5(): String {
    val md = MessageDigest.getInstance("MD5")
    return BigInteger(1, md.digest(toByteArray()))
        .toString(16)
        .padStart(32, '0')
}

fun String.substringBetween(from: String, to: String, fallbackValue: String = this): String {
    val fromIndex = indexOf(from)
    if (fromIndex == -1) {
        return fallbackValue
    }
    val toIndex = lastIndexOf(to)
    return if (toIndex == -1) {
        fallbackValue
    } else {
        substring(fromIndex + from.length, toIndex)
    }
}

fun String.substringBetweenLast(from: String, to: String, fallbackValue: String = this): String {
    val fromIndex = lastIndexOf(from)
    if (fromIndex == -1) {
        return fallbackValue
    }
    val toIndex = lastIndexOf(to)
    return if (toIndex == -1) {
        fallbackValue
    } else {
        substring(fromIndex + from.length, toIndex)
    }
}

fun String.find(regex: Regex) = regex.find(this)?.value

fun String.levenshteinDistance(other: String): Int {
    if (this == other) {
        return 0
    }
    if (this.isEmpty()) {
        return other.length
    }
    if (other.isEmpty()) {
        return this.length
    }

    val lhsLength = this.length + 1
    val rhsLength = other.length + 1

    var cost = Array(lhsLength) { it }
    var newCost = Array(lhsLength) { 0 }

    for (i in 1 until rhsLength) {
        newCost[0] = i

        for (j in 1 until lhsLength) {
            val match = if (this[j - 1] == other[i - 1]) 0 else 1

            val costReplace = cost[j - 1] + match
            val costInsert = cost[j] + 1
            val costDelete = newCost[j - 1] + 1

            newCost[j] = min(min(costInsert, costDelete), costReplace)
        }

        val swap = cost
        cost = newCost
        newCost = swap
    }

    return cost[lhsLength - 1]
}

fun String.toLocalDate(default_format: String = "yyyy-MM-dd") : Date? {
    return try {
        SimpleDateFormat(default_format, Locale.getDefault()).parse(this)
    }catch (ex : Exception){
        ex.printStackTrace()
        null
    }
}

fun Date.toLocalDate(default_format: String = "yyyy-MM-dd") : String? {
    return try {
        SimpleDateFormat(default_format, Locale.getDefault()).format(this)
    }catch (ex : Exception){
        ex.printStackTrace()
        null
    }
}

fun String.getStringDate(initialFormat: String = "yyyy-MM-dd", requiredFormat: String = "yyyy-MM-dd", locale: Locale = Locale.getDefault()): String {
    return this.toDate(initialFormat, locale).toString(requiredFormat, locale)
}

fun String.toDate(format: String = "yyyy-MM-dd", locale: Locale = Locale.getDefault()): Date = SimpleDateFormat(format, locale).parse(this)

fun Date.toString(format: String = "yyyy-MM-dd", locale: Locale = Locale.getDefault()): String {
    val formatter = SimpleDateFormat(format, locale)
    return formatter.format(this)
}

fun String.fromHTML(type : Int = HtmlCompat.FROM_HTML_MODE_LEGACY) : Spanned {
    return HtmlCompat.fromHtml(this, type)
}

fun String?.orValue(value : String = ""): String = this ?: value


fun String.getPlatformDrawable() : Int {
    return when(this.lowercase()){
        "android" -> R.drawable.ic_android
        "ios" -> R.drawable.ic_ios
        "freebsd","freebsd_x86","freebsd_x86-64" -> R.drawable.ic_free_bsd
        "hardware" -> R.drawable.ic_hardware
        "java" -> R.drawable.ic_java
        "json" -> R.drawable.ic_json
        "linux","linux_crisv32","linux_mips","linux_ppc","linux_sparc","linux_x86","linux_x86-64" -> R.drawable.ic_linux
        "macos" -> R.drawable.ic_apple
        "multiple" -> R.drawable.ic_exploit_multiple
        "nodejs" -> R.drawable.ic_nodejs
        "php" -> R.drawable.ic_php
        "python","python2","python3" -> R.drawable.ic_python
        "ruby" -> R.drawable.ic_ruby
        "windows","windows_x86","windows_x86-64" -> R.drawable.ic_windows
        "xml" -> R.drawable.ic_xml
        else -> R.drawable.ic_platform
    }
}