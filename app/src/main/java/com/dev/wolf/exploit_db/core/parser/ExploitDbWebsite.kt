package com.dev.wolf.exploit_db.core.parser

import android.util.Log
import com.dev.wolf.exploit_db.base.domain.LoaderContext
import com.dev.wolf.exploit_db.core.model.*
import com.dev.wolf.exploit_db.utils.ext.*
import okhttp3.Headers

class ExploitDbWebsite(loaderContext: LoaderContext) : RemoteRepository(loaderContext) {

    override val defaultDomain = "www.exploit-db.com"

    private val listBaseUrl = "draw=1&columns[0][data]=date_published&columns[1][data]=download&columns[2][data]=application_md5&columns[3][data]=verified&columns[4][data]=description&columns[5][data]=type_id&columns[6][data]=platform_id&columns[7][data]=author_id&columns[8][data]=code&columns[9][data]=id&order[0][column]=9&order[0][dir]=desc&length=15&author="

    override suspend fun getExploitList(
        offset: Int,
        query: String?,
        type: Type?,
        platform: Platform?,
        port: Port?,
        tag: Tag?
    ): List<Exploit> {
        Log.d("Exploit_db_site", "offset list : $offset")
        val url = buildString {
            append("https://")
            append(defaultDomain)
            if (query != null){
                append("/search?q=${query.urlEncoded()}")
                append("&$listBaseUrl&start=$offset")
            }else
                append("/?$listBaseUrl&start=$offset")
            if (type != null)
                append("&type=${type.key}")
            if (platform != null)
                append("&platform=${platform.key}")
            if (port != null)
                append("&port=${port.key}")
            if (tag != null)
                append("&tag=${tag.key}")
        }
        Log.d("Exploit_db_site", "url list : $url")
        val json = loaderContext.httpGet(url, PREDEFINED_HEADERS).parseJson().getJSONArray("data") ?: parseFailed("Invalid response")
        Log.d("Exploit_db_site", "json : ${json.toString()}")
        val total = json.length()
        val list = ArrayList<Exploit>(total)
        for (i in 0 until total) {
            val jo = json.getJSONObject(i)
            val id = jo.getString("id")
            val expUrl = "/exploits/$id".withDomain()
            val isApp = jo.getString("application_path").isNullOrEmpty()
            list += Exploit(
                id = generateUid(expUrl),
                title = jo.getJSONArray("description").getString(1),
                url = expUrl,
                isVerified = jo.getInt("verified") == 1,
                tags = jo.getJSONArray("tags").mapToSet {
                    Tag(
                        key = it.getString("id"),
                        title = it.getString("title")
                    ) },
                author = jo.getJSONArray("author_id").getString(1),
                createdAt = jo.getString("date_published").toLocalDate(),
                isApplication = Pair(isApp,jo.getString("application_path")),
                type = Type(jo.getString("type_id"), jo.getString("type_id").lowercase()),
                platform = Platform(jo.getString("platform_id"),jo.getString("platform_id").lowercase()),
                edb_id = id,
                cve = jo.getJSONArray("code").mapToSet {
                    CVE(
                        code_id = it.getString("id"),
                        code_type = it.getString("code_type"),
                        code = it.getString("code")
                    ) },
            )
        }
        return list
    }

    override suspend fun getDetails(exploit: Exploit): Exploit = exploit

    override suspend fun getTags(): Set<Tag> {
        val doc = loaderContext.httpGet("https://$defaultDomain").parseHtml()
        val root = doc.body().getElementById("tagSelect") ?: parseFailed("Root not found")
        return root.select("option").mapNotNullToSet { option ->
            Tag(
                key = option.attr("value"),
                title = option.ownText()
            )
        }
    }

    override suspend fun getTypes(): Set<Type> {
        val doc = loaderContext.httpGet("https://$defaultDomain").parseHtml()
        val root = doc.body().getElementById("typeSelect") ?: parseFailed("Root not found")
        return root.select("option").mapNotNullToSet { option ->
            Type(
                key = option.attr("value"),
                title = option.ownText()
            )
        }
    }

    override suspend fun getPlatforms(): Set<Platform> {
        val doc = loaderContext.httpGet("https://$defaultDomain").parseHtml()
        val root = doc.body().getElementById("platformSelect") ?: parseFailed("Root not found")
        return root.select("option").mapNotNullToSet { option ->
            Platform(
                key = option.attr("value"),
                title = option.ownText()
            )
        }
    }

    override suspend fun getPorts(): Set<Port> {
        val doc = loaderContext.httpGet("https://$defaultDomain").parseHtml()
        val root = doc.body().getElementById("platformSelect") ?: parseFailed("Root not found")
        return root.select("option").mapNotNullToSet { option ->
            Port(
                key = option.attr("value"),
                title = option.ownText()
            )
        }
    }

    private companion object {
        val PREDEFINED_HEADERS = Headers.Builder()
            .add("x-requested-with", "XMLHttpRequest")
            .build()
    }
}