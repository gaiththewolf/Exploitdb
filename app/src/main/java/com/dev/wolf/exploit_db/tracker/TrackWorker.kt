package com.dev.wolf.exploit_db.tracker

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.graphics.BitmapFactory
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.LiveData
import androidx.lifecycle.map
import androidx.work.*
import com.dev.wolf.exploit_db.core.prefs.AppSettings
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.core.parser.ExploitRepository
import com.dev.wolf.exploit_db.ui.detail.ui.DetailsActivity
import com.dev.wolf.exploit_db.utils.PendingIntentCompat
import com.dev.wolf.exploit_db.utils.Progress
import com.dev.wolf.exploit_db.utils.ext.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import java.util.concurrent.TimeUnit

class TrackWorker(context: Context, workerParams: WorkerParameters) :
    CoroutineWorker(context, workerParams), KoinComponent {

    private val notificationManager by lazy {
        applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    }

    private val repository by inject<TrackingRepository>()
    private val remoteRepository by inject<ExploitRepository>()
    private val settings by inject<AppSettings>()

    override suspend fun doWork(): Result {
        repository.cleanup()
        setForeground(createForegroundInfo())
        var success = 0
        val listExploits = remoteRepository.getExploitList(
            offset = 0,
            type = null,
            platform = null,
            port = null,
            tag = null,
            verified = false,
            hasapp = false,
            nomsf = false,
        )
        if (listExploits.isNullOrEmpty()) {
            return Result.success()
        }
        val workData = Data.Builder().putInt(DATA_TOTAL, listExploits.size)
        val notifiedList = repository.getTrackedList()
        listExploits.mapIndexed { index, it ->
            workData.putInt(DATA_PROGRESS, index)
            setProgress(workData.build())
            if (it.createdAt.isToday() && !notifiedList.contains(it)){
                repository.storeTrackResult(it)
                showNotification(it)
                success++
            }
        }
        return if (success == 0) {
            Result.retry()
        } else {
            Result.success()
        }
    }

    private fun createForegroundInfo(): ForegroundInfo {
        val title = applicationContext.getString(R.string.new_exploits_checking)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                WORKER_CHANNEL_ID,
                title,
                NotificationManager.IMPORTANCE_LOW
            )
            channel.setShowBadge(false)
            channel.enableVibration(false)
            channel.setSound(null, null)
            channel.enableLights(false)
            notificationManager.createNotificationChannel(channel)
        }

        val notification = NotificationCompat.Builder(applicationContext, WORKER_CHANNEL_ID)
            .setContentTitle(title)
            .setPriority(NotificationCompat.PRIORITY_MIN)
            .setDefaults(0)
            .setColor(ContextCompat.getColor(applicationContext, R.color.blue_primary_dark))
            .setSilent(true)
            .setProgress(0, 0, true)
            .setSmallIcon(android.R.drawable.stat_notify_sync)
            .setOngoing(true)
            .build()

        return ForegroundInfo(WORKER_NOTIFICATION_ID, notification)
    }

    private suspend fun showNotification(exploit: Exploit) {
        if (!settings.trackerNotifications) return
        if (exploit.type?.key !in settings.notificationFilterTypes) return
        if (exploit.platform?.key !in settings.notificationFilterPlatforms) return

        val id = exploit.url.hashCode()
        val colorPrimary = ContextCompat.getColor(applicationContext, R.color.red_accent)
        val builder = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
        val title = applicationContext.getString(
            R.string.notifications_title,
            exploit.type?.title.orValue("-") ,
            exploit.platform?.title.orValue("-"))
        val summary = exploit.title.fromHTML()
        with(builder) {
            setContentText(summary)
            setContentTitle(title)
            setSmallIcon(R.drawable.ic_stat_spider_white)
            setLargeIcon(BitmapFactory.decodeResource(
                applicationContext.resources, R.mipmap.ic_launcher_round))
            val style = NotificationCompat.InboxStyle(this)
            style.addLine(applicationContext.getString(R.string.type_s, exploit.type?.title))
            style.addLine(applicationContext.getString(R.string.platform_s, exploit.platform?.title))
            style.addLine(applicationContext.getString(R.string.author_s, exploit.author))
            style.setSummaryText(title)
            style.setBigContentTitle(summary)
            setStyle(style)
            val intent = DetailsActivity.newIntent(applicationContext, exploit)
            setContentIntent(
                PendingIntent.getActivity(
                    applicationContext, id,
                    intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntentCompat.FLAG_IMMUTABLE
                )
            )
            setAutoCancel(true)
            color = colorPrimary
            setShortcutId(exploit.id.toString())
            priority = NotificationCompat.PRIORITY_DEFAULT
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
                builder.setSound(settings.notificationSound.toUriOrNull())
                var defaults = if (settings.notificationLight) {
                    setLights(colorPrimary, 1000, 5000)
                    NotificationCompat.DEFAULT_LIGHTS
                } else 0
                if (settings.notificationVibrate) {
                    builder.setVibrate(longArrayOf(500, 500, 500, 500))
                    defaults = defaults or NotificationCompat.DEFAULT_VIBRATE
                }
                builder.setDefaults(defaults)
            }
        }
        withContext(Dispatchers.Main) {
            notificationManager.notify(TAG, id, builder.build())
        }
    }

    companion object {

        const val CHANNEL_ID = "tracking"
        private const val WORKER_CHANNEL_ID = "track_worker"
        private const val WORKER_NOTIFICATION_ID = 69
        private const val DATA_PROGRESS = "progress"
        private const val DATA_TOTAL = "total"
        private const val TAG = "tracking"

        @RequiresApi(Build.VERSION_CODES.O)
        private fun createNotificationChannel(context: Context) {
            val manager =
                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            if (manager.getNotificationChannel(CHANNEL_ID) == null) {
                val channel = NotificationChannel(
                    CHANNEL_ID,
                    context.getString(R.string.new_exploits),
                    NotificationManager.IMPORTANCE_DEFAULT
                )
                channel.setShowBadge(true)
                channel.lightColor = ContextCompat.getColor(context, R.color.blue_primary_dark)
                channel.enableLights(true)
                manager.createNotificationChannel(channel)
            }
        }

        fun setup(context: Context) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                createNotificationChannel(context)
            }
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val request = PeriodicWorkRequestBuilder<TrackWorker>(4, TimeUnit.HOURS)
                .setConstraints(constraints)
                .addTag(TAG)
                .setBackoffCriteria(BackoffPolicy.LINEAR, 30, TimeUnit.MINUTES)
                .build()
            WorkManager.getInstance(context)
                .enqueueUniquePeriodicWork(TAG, ExistingPeriodicWorkPolicy.KEEP, request)
        }

        fun startNow(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val request = OneTimeWorkRequestBuilder<TrackWorker>()
                .setConstraints(constraints)
                .addTag(TAG)
                .build()
            WorkManager.getInstance(context)
                .enqueue(request)
        }

        fun getProgressLiveData(context: Context): LiveData<Progress?> {
            return WorkManager.getInstance(context)
                .getWorkInfosByTagLiveData(TAG)
                .map { list ->
                    list.find { work ->
                        work.state == WorkInfo.State.RUNNING
                    }?.let { workInfo ->
                        Progress(
                            value = workInfo.progress.getInt(DATA_PROGRESS, 0),
                            total = workInfo.progress.getInt(DATA_TOTAL, -1)
                        ).takeUnless { it.isIndeterminate }
                    }
                }
        }
    }
}