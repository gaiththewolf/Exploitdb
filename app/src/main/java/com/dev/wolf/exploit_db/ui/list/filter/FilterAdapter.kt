package com.dev.wolf.exploit_db.ui.list.filter

import android.util.Log
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.dev.wolf.exploit_db.base.list.BaseViewHolder
import com.dev.wolf.exploit_db.core.model.*
import java.util.*
import kotlin.collections.ArrayList

class FilterAdapter(
    types: List<Type> = emptyList(),
    platforms: List<Platform> = emptyList(),
    ports: List<Port> = emptyList(),
    tags: List<Tag> = emptyList(),
    state: ExploitFilter?,
    private val listener: OnFilterChangedListener
) : RecyclerView.Adapter<BaseViewHolder<*, Boolean, *>>() {

    private val types =  ArrayList(Collections.singletonList(null) + types)
    private val platforms =  ArrayList(Collections.singletonList(null) + platforms)
    private val ports =  ArrayList(Collections.singletonList(null) + ports)
    private val tags = ArrayList(Collections.singletonList(null) + tags)

    private var currentState = state ?: ExploitFilter(null, null, null, null)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = when (viewType) {
        VIEW_TYPE_TYPE -> FilterTypeHolder(parent).apply {
            itemView.setOnClickListener {
                setCheckedType(boundData)
            }
        }
        VIEW_TYPE_PLATFORM -> FilterPlatformHolder(parent).apply {
            itemView.setOnClickListener {
                setCheckedPlatform(boundData)
            }
        }
        VIEW_TYPE_PORT -> FilterPortHolder(parent).apply {
            itemView.setOnClickListener {
                setCheckedPort(boundData)
            }
        }
        VIEW_TYPE_TAG -> FilterTagHolder(parent).apply {
            itemView.setOnClickListener {
                setCheckedTag(boundData)
            }
        }
        else -> throw IllegalArgumentException("Unknown viewType $viewType")
    }

    override fun getItemCount() = types.size + platforms.size + ports.size + tags.size

    override fun onBindViewHolder(holder: BaseViewHolder<*, Boolean, *>, position: Int) {
        when (holder) {
            is FilterTypeHolder -> {
                val item = types[position]
                holder.bind(item, item == currentState.type)
            }
            is FilterPlatformHolder -> {
                val item = platforms[position  - types.size]
                holder.bind(item, item == currentState.platform)
            }
            is FilterPortHolder -> {
                val item = ports[position - platforms.size]
                holder.bind(item, item == currentState.port)
            }
            is FilterTagHolder -> {
                val item = tags[position - ports.size]
                holder.bind(item, item == currentState.tag)
            }
        }
    }

    override fun getItemViewType(position: Int) = when (position) {
        in types.indices -> VIEW_TYPE_TYPE
        in platforms.indices -> VIEW_TYPE_PLATFORM
        in ports.indices -> VIEW_TYPE_PORT
        else -> VIEW_TYPE_TAG
    }

    fun setCheckedType(type: Type?) {
        if (type != currentState.type) {
            val oldItemPos = types.indexOf(currentState.type)
            val newItemPos = types.indexOf(type)
            currentState = currentState.copy(type = type)
            if (oldItemPos in types.indices) {
                notifyItemChanged(oldItemPos)
            }
            if (newItemPos in types.indices) {
                notifyItemChanged(newItemPos)
            }
            listener.onFilterChanged(currentState)
        }
    }

    fun setCheckedPlatform(platform: Platform?) {
        if (platform != currentState.platform) {
            val oldItemPos = platforms.indexOf(currentState.platform)
            val newItemPos = platforms.indexOf(platform)
            currentState = currentState.copy(platform = platform)
            if (oldItemPos in types.indices) {
                notifyItemChanged(types.size + oldItemPos)
            }
            if (newItemPos in types.indices) {
                notifyItemChanged(types.size + newItemPos)
            }
            listener.onFilterChanged(currentState)
        }
    }

    fun setCheckedPort(port: Port?) {
        if (port != currentState.port) {
            val oldItemPos = ports.indexOf(currentState.port)
            val newItemPos = ports.indexOf(port)
            currentState = currentState.copy(port = port)
            if (oldItemPos in types.indices) {
                notifyItemChanged(types.size + platforms.size + oldItemPos)
            }
            if (newItemPos in types.indices) {
                notifyItemChanged(types.size + platforms.size + newItemPos)
            }
            listener.onFilterChanged(currentState)
        }
    }

    fun setCheckedTag(tag: Tag?) {
        if (tag != currentState.tag) {
            val oldItemPos = tags.indexOf(currentState.tag)
            val newItemPos = tags.indexOf(tag)
            currentState = currentState.copy(tag = tag)
            if (oldItemPos in tags.indices) {
                notifyItemChanged(types.size + platforms.size + ports.size + oldItemPos)
            }
            if (newItemPos in tags.indices) {
                notifyItemChanged(types.size + platforms.size + ports.size + newItemPos)
            }
            listener.onFilterChanged(currentState)
        }
    }

    companion object {
        const val VIEW_TYPE_TYPE = 0
        const val VIEW_TYPE_PLATFORM = 1
        const val VIEW_TYPE_PORT = 2
        const val VIEW_TYPE_TAG = 3
    }
}