package com.dev.wolf.exploit_db.ui.list

import android.util.Log
import androidx.lifecycle.viewModelScope
import com.dev.wolf.exploit_db.BuildConfig
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.base.BaseViewModel
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.core.model.ExploitFilter
import com.dev.wolf.exploit_db.core.parser.ExploitRepository
import com.dev.wolf.exploit_db.core.prefs.AppSettings
import com.dev.wolf.exploit_db.ui.list.model.*
import com.dev.wolf.exploit_db.utils.ext.asLiveDataDistinct
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine

class RemoteListViewModel(private val repository: ExploitRepository, settings: AppSettings):
    ExploitListViewModel(settings) {

    private val exploitList = MutableStateFlow<List<Exploit>?>(null)
    private val hasNextPage = MutableStateFlow(false)
    private val listError = MutableStateFlow<Throwable?>(null)
    private var loadingJob: Job? = null
    private var appliedFilter: ExploitFilter? = null

    private fun loadList(append: Boolean) {
        if (loadingJob?.isActive == true) {
            return
        }
        loadingJob = launchLoadingJob(Dispatchers.Default) {
            try {
                listError.value = null
                val list = repository.getExploitList(
                    offset = if (append) exploitList.value?.size ?: 0 else 0,
                    type = appliedFilter?.type,
                    platform = appliedFilter?.platform,
                    port = appliedFilter?.port,
                    tag = appliedFilter?.tag,
                )
                if (!append) {
                    exploitList.value = list
                } else if (list.isNotEmpty()) {
                    exploitList.value = exploitList.value?.plus(list) ?: list
                }
                hasNextPage.value = list.isNotEmpty()
            } catch (e: Throwable) {
                listError.value = e
            }
        }
    }

    fun loadNextPage() {
        if (hasNextPage.value && listError.value == null) {
            loadList(append = true)
        }
    }

    init {
        loadList(false)
        loadFilter()
    }

    override fun onRefresh() {
        loadList(append = false)
    }

    override fun onRetry() {
        loadList(append = !exploitList.value.isNullOrEmpty())
    }

    override val content = combine(
        exploitList,
        listError,
        hasNextPage
    ) { list, error, hasNext ->
        when {
            list.isNullOrEmpty() && error != null -> listOf(error.toErrorState(canRetry = true))
            list == null -> listOf(LoadingState)
            list.isEmpty() -> listOf(EmptyState(R.drawable.ic_error, R.string.nothing_found, R.string._empty))
            else -> {
                val result = ArrayList<ListModel>(list.size + 2)
                list.toUi(result)
                when {
                    error != null -> result += error.toErrorFooter()
                    hasNext -> result += LoadingFooter
                }
                result
            }
        }
    }.asLiveDataDistinct(viewModelScope.coroutineContext + Dispatchers.Default, listOf(LoadingState))

    fun applyFilter(newFilter: ExploitFilter) {
        appliedFilter = newFilter
        exploitList.value = null
        hasNextPage.value = false
        loadList(false)
        filter.value?.run {
            filter.value = copy(currentFilter = newFilter)
        }
    }

    private fun loadFilter() {
        launchJob(Dispatchers.Default) {
            try {
                val filters = repository.getFilters()
                filter.postValue(ExploitFilterConfig(filters.types.orEmpty(),filters.platforms.orEmpty(),filters.ports.orEmpty(),filters.tags.orEmpty(), appliedFilter))
            } catch (e: Exception) {
                if (BuildConfig.DEBUG) {
                    e.printStackTrace()
                }
            }
        }
    }
}