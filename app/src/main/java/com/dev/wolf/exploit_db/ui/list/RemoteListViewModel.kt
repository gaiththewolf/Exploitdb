package com.dev.wolf.exploit_db.ui.list

import androidx.lifecycle.viewModelScope
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.base.BaseViewModel
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.core.parser.ExploitRepository
import com.dev.wolf.exploit_db.core.prefs.AppSettings
import com.dev.wolf.exploit_db.ui.list.model.*
import com.dev.wolf.exploit_db.utils.ext.asLiveDataDistinct
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine

class RemoteListViewModel(private val repository: ExploitRepository, settings: AppSettings):
    ExploitListViewModel(settings) {

    private val exploitList = MutableStateFlow<List<Exploit>?>(null)
    private val hasNextPage = MutableStateFlow(false)
    private val listError = MutableStateFlow<Throwable?>(null)
    private var loadingJob: Job? = null

    private fun loadList(append: Boolean) {
        if (loadingJob?.isActive == true) {
            return
        }
        loadingJob = launchLoadingJob(Dispatchers.Default) {
            try {
                listError.value = null
                val list = repository.getExploitList(
                    offset = if (append) exploitList.value?.size ?: 0 else 0,
                )
                if (!append) {
                    exploitList.value = list
                } else if (list.isNotEmpty()) {
                    exploitList.value = exploitList.value?.plus(list) ?: list
                }
                hasNextPage.value = list.isNotEmpty()
            } catch (e: Throwable) {
                listError.value = e
            }
        }
    }

    fun loadNextPage() {
        if (hasNextPage.value && listError.value == null) {
            loadList(append = true)
        }
    }

    init {
        loadList(false)
    }

    override fun onRefresh() {
        loadList(append = false)
    }

    override fun onRetry() {
        loadList(append = !exploitList.value.isNullOrEmpty())
    }

    override val content = combine(
        exploitList,
        listError,
        hasNextPage
    ) { list, error, hasNext ->
        when {
            list.isNullOrEmpty() && error != null -> listOf(error.toErrorState(canRetry = true))
            list == null -> listOf(LoadingState)
            list.isEmpty() -> listOf(EmptyState(R.drawable.ic_error, R.string.nothing_found, R.string._empty))
            else -> {
                val result = ArrayList<ListModel>(list.size + 2)
                list.toUi(result)
                when {
                    error != null -> result += error.toErrorFooter()
                    hasNext -> result += LoadingFooter
                }
                result
            }
        }
    }.asLiveDataDistinct(viewModelScope.coroutineContext + Dispatchers.Default, listOf(LoadingState))
}