package com.dev.wolf.exploit_db.settings

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.annotation.MainThread
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import com.dev.wolf.exploit_db.BuildConfig
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.core.github.AppVersion
import com.dev.wolf.exploit_db.core.github.GithubRepository
import com.dev.wolf.exploit_db.core.github.VersionId
import com.dev.wolf.exploit_db.core.prefs.AppSettings
import com.dev.wolf.exploit_db.utils.FileSizeUtils
import com.dev.wolf.exploit_db.utils.ext.byte2HexFormatted
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.koin.android.ext.android.get
import java.io.ByteArrayInputStream
import java.io.InputStream
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.util.concurrent.TimeUnit

class AppUpdateChecker(private val activity: ComponentActivity) {

    private val settings = activity.get<AppSettings>()
    private val repo = activity.get<GithubRepository>()

    fun launchIfNeeded(): Job? {
        return if (settings.appUpdateAuto && settings.appUpdate + PERIOD < System.currentTimeMillis()) {
            launch()
        } else {
            null
        }
    }

    fun launch(): Job? {
        return if (isUpdateSupported(activity)) {
            launchInternal()
        } else {
            null
        }
    }

    suspend fun checkNow() = runCatching {
        withContext(Dispatchers.Default) {
            val version = repo.getLatestVersion()
            val newVersionId = VersionId.parse(version.name)
            val currentVersionId = VersionId.parse(BuildConfig.VERSION_NAME)
            val result = newVersionId > currentVersionId
            if (result) {
                withContext(Dispatchers.Main) {
                    showUpdateDialog(version)
                }
            }
            settings.appUpdate = System.currentTimeMillis()
            result
        }
    }.onFailure {
        it.printStackTrace()
    }.getOrNull()

    private fun launchInternal() = activity.lifecycleScope.launch {
        checkNow()
    }

    @MainThread
    private fun showUpdateDialog(version: AppVersion) {
        AlertDialog.Builder(activity)
            .setTitle(R.string.app_update_available)
            .setMessage(buildString {
                append(activity.getString(R.string.new_version_s, version.name))
                appendLine()
                append(
                    activity.getString(
                        R.string.size_s,
                        FileSizeUtils.formatBytes(activity, version.apkSize)
                    )
                )
                appendLine()
                appendLine()
                append(version.description)
            })
            .setPositiveButton(R.string.download) { _, _ ->
                activity.startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(version.apkUrl)))
            }
            .setNegativeButton(R.string.close, null)
            .create()
            .show()
    }

    companion object {

        private const val CERT_SHA1 = "9F:A4:98:F9:5A:94:DA:02:CE:7A:0B:13:95:2A:99:A5:BA:6B:60:D0"
        private val PERIOD = TimeUnit.HOURS.toMillis(6)

        fun isUpdateSupported(context: Context): Boolean {
            return getCertificateSHA1Fingerprint(context) == CERT_SHA1
        }

        @Suppress("DEPRECATION")
        @SuppressLint("PackageManagerGetSignatures")
        private fun getCertificateSHA1Fingerprint(context: Context): String? {
            val packageInfo = try {
                context.packageManager.getPackageInfo(
                    context.packageName,
                    PackageManager.GET_SIGNATURES
                )
            } catch (e: PackageManager.NameNotFoundException) {
                e.printStackTrace()
                return null
            }
            val signatures = packageInfo?.signatures
            val cert: ByteArray = signatures?.firstOrNull()?.toByteArray() ?: return null
            val input: InputStream = ByteArrayInputStream(cert)
            val c = try {
                val cf = CertificateFactory.getInstance("X509")
                cf.generateCertificate(input) as X509Certificate
            } catch (e: CertificateException) {
                e.printStackTrace()
                return null
            }
            return try {
                val md: MessageDigest = MessageDigest.getInstance("SHA1")
                val publicKey: ByteArray = md.digest(c.encoded)
                publicKey.byte2HexFormatted()
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
                null
            } catch (e: CertificateEncodingException) {
                e.printStackTrace()
                null
            }
        }
    }
}