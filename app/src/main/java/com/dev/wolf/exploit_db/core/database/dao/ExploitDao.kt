package com.dev.wolf.exploit_db.core.database.dao

import androidx.room.*
import com.dev.wolf.exploit_db.core.database.entity.*

@Dao
abstract class ExploitDao {

    @Transaction
    @Query("SELECT * FROM exploit WHERE exploit_id = :id")
    abstract suspend fun find(id: Long): ExploitWithTagsCves?

    @Transaction
    @Query("SELECT * FROM exploit WHERE title LIKE :query OR code LIKE :query LIMIT :limit")
    abstract suspend fun searchByTitle(query: String, limit: Int): List<ExploitWithTagsCves>

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    abstract suspend fun insert(exploit: ExploitEntity): Long

    @Update(onConflict = OnConflictStrategy.IGNORE)
    abstract suspend fun update(exploit: ExploitEntity): Int

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    abstract suspend fun insertTagRelation(tag: ExploitTagsEntity): Long

    @Query("DELETE FROM exploit_tags WHERE exploit_id = :exploitId")
    abstract suspend fun clearTagRelation(exploitId: Long)

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    abstract suspend fun insertCveRelation(tag: ExploitCvesEntity): Long

    @Query("DELETE FROM exploit_cves WHERE exploit_id = :exploitId")
    abstract suspend fun clearCveRelation(exploitId: Long)

    @Transaction
    open suspend fun upsert(exploit: ExploitEntity, tags: Iterable<TagEntity>? = null, cves: Iterable<CveEntity>? = null) {
        if (update(exploit) <= 0) {
            insert(exploit)
            if (tags != null) {
                clearTagRelation(exploit.id)
                tags.map {
                    ExploitTagsEntity(exploit.id, it.id)
                }.forEach {
                    insertTagRelation(it)
                }
            }
            if (cves != null) {
                clearCveRelation(exploit.id)
                cves.map {
                    ExploitCvesEntity(exploit.id, it.id)
                }.forEach {
                    insertCveRelation(it)
                }
            }
        }
    }
}