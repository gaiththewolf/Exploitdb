package com.dev.wolf.exploit_db.search

import android.annotation.SuppressLint
import android.app.SearchManager
import android.content.Context
import android.provider.SearchRecentSuggestions
import com.dev.wolf.exploit_db.core.database.ExploitDatabase
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.search.ui.ExploitSuggestionsProvider
import com.dev.wolf.exploit_db.utils.ext.levenshteinDistance
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.isActive
import kotlinx.coroutines.withContext

class ExploitSearchRepository(
    private val db: ExploitDatabase,
    private val context: Context,
    private val recentSuggestions: SearchRecentSuggestions,
) {


    suspend fun getSuggestion(query: String, limit: Int): List<Exploit> {
        if (query.isEmpty()) {
            return emptyList()
        }
        return db.exploitDao.searchByTitle("%$query%", limit) .map { it.toExploit() }
            .sortedBy { x -> x.title.levenshteinDistance(query) }
    }

    suspend fun getQuerySuggestion(
        query: String,
        limit: Int,
    ): List<String> = withContext(Dispatchers.IO) {
        context.contentResolver.query(
            ExploitSuggestionsProvider.QUERY_URI,
            SUGGESTION_PROJECTION,
            "${SearchManager.SUGGEST_COLUMN_QUERY} LIKE ?",
            arrayOf("%$query%"),
            "date DESC"
        )?.use { cursor ->
            val count = minOf(cursor.count, limit)
            if (count == 0) {
                return@withContext emptyList()
            }
            val result = ArrayList<String>(count)
            if (cursor.moveToFirst()) {
                val index = cursor.getColumnIndexOrThrow(SearchManager.SUGGEST_COLUMN_QUERY)
                do {
                    result += cursor.getString(index)
                } while (currentCoroutineContext().isActive && cursor.moveToNext())
            }
            result
        }.orEmpty()
    }

    fun saveSearchQuery(query: String) {
        recentSuggestions.saveRecentQuery(query, null)
    }

    suspend fun clearSearchHistory(): Unit = withContext(Dispatchers.IO) {
        recentSuggestions.clearHistory()
    }

    suspend fun deleteSearchQuery(query: String) = withContext(Dispatchers.IO) {
        context.contentResolver.delete(
            ExploitSuggestionsProvider.URI,
            "display1 = ?",
            arrayOf(query),
        )
    }

    suspend fun getSearchHistoryCount(): Int = withContext(Dispatchers.IO) {
        context.contentResolver.query(
            ExploitSuggestionsProvider.QUERY_URI,
            SUGGESTION_PROJECTION,
            null,
            arrayOfNulls(1),
            null
        )?.use { cursor -> cursor.count } ?: 0
    }

    private companion object {

        private val REGEX_SPACE = Regex("\\s+")
        val SUGGESTION_PROJECTION = arrayOf(SearchManager.SUGGEST_COLUMN_QUERY)

        @SuppressLint("DefaultLocale")
        fun match(exploit: Exploit, query: String): Boolean {
            val words = HashSet<String>()
            words += exploit.title.lowercase().split(REGEX_SPACE)
            val words2 = query.lowercase().split(REGEX_SPACE).toSet()
            for (w in words) {
                for (w2 in words2) {
                    val diff = w.levenshteinDistance(w2) / ((w.length + w2.length) / 2f)
                    if (diff < 0.5) {
                        return true
                    }
                }
            }
            return false
        }
    }
}