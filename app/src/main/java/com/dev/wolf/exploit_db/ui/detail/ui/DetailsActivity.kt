package com.dev.wolf.exploit_db.ui.detail.ui

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.view.ActionMode
import androidx.appcompat.widget.Toolbar
import androidx.core.view.updatePadding
import com.dev.wolf.exploit_db.base.BaseActivity
import com.dev.wolf.exploit_db.base.domain.ExploitIntent
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.databinding.ActivityDetailsBinding
import com.dev.wolf.exploit_db.utils.ext.getDisplayMessage
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.tabs.TabLayoutMediator
import org.koin.androidx.viewmodel.ext.android.viewModel
import org.koin.core.parameter.parametersOf
import androidx.core.graphics.Insets
import com.dev.wolf.exploit_db.BuildConfig
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.utils.ext.fromHTML
import com.google.android.material.tabs.TabLayout

class DetailsActivity : BaseActivity<ActivityDetailsBinding>(),
    TabLayoutMediator.TabConfigurationStrategy {

    private val viewModel by viewModel<DetailsViewModel>(mode = LazyThreadSafetyMode.NONE) {
        parametersOf(ExploitIntent.from(intent))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(ActivityDetailsBinding.inflate(layoutInflater))
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        binding.pager.adapter = TabDetailsAdapter(this)
        TabLayoutMediator(binding.tabs, binding.pager, this).attach()

        viewModel.exploit.observe(this, ::onExploitUpdated)
        viewModel.onError.observe(this, ::onError)
    }

    private fun onExploitUpdated(exploit: Exploit) {
        title = exploit.title.fromHTML()
        invalidateOptionsMenu()
    }

    private fun onError(e: Throwable) {
        when (viewModel.exploit.value) {
            null -> {
                Toast.makeText(this, e.getDisplayMessage(resources), Toast.LENGTH_LONG).show()
                finishAfterTransition()
            }
            else -> {
                Snackbar.make(binding.pager, e.getDisplayMessage(resources), Snackbar.LENGTH_LONG)
                    .show()
            }
        }
    }

    override fun onWindowInsetsChanged(insets: Insets) {
        binding.toolbar.updatePadding(
            top = insets.top,
            left = insets.left,
            right = insets.right
        )
        if (binding.tabs.parent !is Toolbar) {
            binding.tabs.updatePadding(
                left = insets.left,
                right = insets.right
            )
        }
    }

    override fun onConfigureTab(tab: TabLayout.Tab, position: Int) {
        tab.text = when (position) {
            0 -> getString(R.string.details)
            1 -> getString(R.string.code)
            else -> null
        }
    }

    override fun onSupportActionModeStarted(mode: ActionMode) {
        super.onSupportActionModeStarted(mode)
        binding.pager.isUserInputEnabled = false
    }

    override fun onSupportActionModeFinished(mode: ActionMode) {
        super.onSupportActionModeFinished(mode)
        binding.pager.isUserInputEnabled = true
    }

    companion object {

        const val ACTION_EXPLOIT_VIEW = "${BuildConfig.APPLICATION_ID}.action.VIEW_EXPLOIT"

        fun newIntent(context: Context, exploit: Exploit): Intent {
            return Intent(context, DetailsActivity::class.java)
                .putExtra(ExploitIntent.KEY_EXPLOIT, exploit)
        }

        fun newIntent(context: Context, exploitId: Long): Intent {
            return Intent(context, DetailsActivity::class.java)
                .putExtra(ExploitIntent.KEY_ID, exploitId)
        }
    }
}