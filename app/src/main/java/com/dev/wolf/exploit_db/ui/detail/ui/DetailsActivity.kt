package com.dev.wolf.exploit_db.ui.detail.ui

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.core.graphics.Insets
import androidx.core.view.isVisible
import androidx.core.view.updatePadding
import com.dev.wolf.exploit_db.BuildConfig
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.base.BaseActivity
import com.dev.wolf.exploit_db.base.domain.ExploitIntent
import com.dev.wolf.exploit_db.base.widgets.ChipsView
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.databinding.ActivityDetailsBinding
import com.dev.wolf.exploit_db.utils.ShareHelper
import com.dev.wolf.exploit_db.utils.ext.*
import com.google.android.material.snackbar.Snackbar
import org.koin.androidx.viewmodel.ext.android.viewModel
import org.koin.core.parameter.parametersOf

class DetailsActivity : BaseActivity<ActivityDetailsBinding>() {

    private val viewModel by viewModel<DetailsViewModel>(mode = LazyThreadSafetyMode.NONE) {
        parametersOf(ExploitIntent.from(intent))
    }

    private var isFav : Boolean = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(ActivityDetailsBinding.inflate(layoutInflater))
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        viewModel.exploit.observe(this, ::onExploitUpdated)
        viewModel.isLoading.observe(this, ::onLoadingStateChanged)
        viewModel.onError.observe(this, ::onError)
        viewModel.favouriteCategories.observe(this, ::onFavouriteChanged)
    }

    private fun onExploitUpdated(exploit: Exploit) {
        title = getString(R.string.app_name)
        supportActionBar?.subtitle = exploit.title.fromHTML()
        with(binding) {
            textViewTitle.text = exploit.title.fromHTML()
            textViewDate.textAndVisible = exploit.createdAt.toLocalDate()
            textViewAuthor.textAndVisible = exploit.author
            textViewAuthor.text = exploit.author
            textViewEdbId.text = exploit.edb_id
            textViewPlatform.textAndVisible = exploit.platform?.title
            namePlatform.setCompoundDrawablesWithIntrinsicBounds(
                exploit.platform?.key?.getPlatformDrawable() ?: R.drawable.ic_platform,
                0,0,0)
            textViewType.textAndVisible = exploit.type?.title

            if (exploit.port != null)
                textViewPort.textAndVisible = exploit.port.title
            else
                portContainer.isVisible = false

            if (exploit.isVerified)
                imageViewVerified.setImageDrawable(ContextCompat.getDrawable(this@DetailsActivity, R.drawable.ic_verified))
            else
                imageViewVerified.setImageDrawable(ContextCompat.getDrawable(this@DetailsActivity, R.drawable.ic_not_verified))

            if (exploit.isApplication.first){
                textViewAppName.text = exploit.isApplication.second
            }else
                appContainer.isVisible = false

            buttonShowExploitCode.isEnabled = !exploit.code.isNullOrEmpty()
            buttonShowExploitCode.setOnClickListener {
                startActivity(ExploitCodeActivity.newIntent(this@DetailsActivity, exploit))
            }

            buttonFavorite.setOnClickListener {
                if (isFav)
                    viewModel.removeFromFavourites(exploit)
                else
                    viewModel.addToFavourites(exploit)
            }

            bindTagsAndCve(exploit)
        }
        invalidateOptionsMenu()
    }

    private fun bindTagsAndCve(exploit: Exploit) {
        if (exploit.tags.isEmpty()){
            binding.chipsTags.isVisible = false
            binding.tagsHeader.isVisible = false
        }else{
            binding.chipsTags.setChips(
                exploit.tags.map { tag ->
                    ChipsView.ChipModel(
                        title = tag.title,
                        icon = 0
                    )
                }
            )
        }
        if (exploit.cve.isEmpty()){
            binding.chipsCve.isVisible = false
            binding.cveHeader.isVisible = false
        }else{
            binding.chipsCve.setChips(
                exploit.cve.map { cve ->
                    ChipsView.ChipModel(
                        title = cve.code,
                        icon = 0
                    )
                }
            )
        }
    }

    private fun onFavouriteChanged(isFavourite: Boolean) {
        isFav = isFavourite
        with(binding.buttonFavorite) {
            if (isFavourite) {
                this.setIconResource(R.drawable.ic_heart)
            } else {
                this.setIconResource(R.drawable.ic_heart_outline)
            }
        }
    }

    private fun onLoadingStateChanged(isLoading: Boolean) {
        if (isLoading) {
            binding.progressBar.show()
        } else {
            binding.progressBar.hide()
        }
    }

    private fun onError(e: Throwable) {
        when (viewModel.exploit.value) {
            null -> {
                Toast.makeText(this, e.getDisplayMessage(resources), Toast.LENGTH_LONG).show()
                finishAfterTransition()
            }
            else -> {
                Snackbar.make(binding.pager, e.getDisplayMessage(resources), Snackbar.LENGTH_LONG)
                    .show()
            }
        }
    }

    override fun onWindowInsetsChanged(insets: Insets) {
        binding.toolbar.updatePadding(
            top = insets.top,
            left = insets.left,
            right = insets.right
        )
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.opt_exploit_detail, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean = when (item.itemId) {
        R.id.action_code_browser -> {
            val intent = Intent(Intent.ACTION_VIEW)
            intent.data = Uri.parse(viewModel.exploit.value?.codeUrl())
            try {
                startActivity(Intent.createChooser(intent, item.title))
            } catch (_: ActivityNotFoundException) {
            }
            true
        }
        R.id.action_exploit_browser -> {
            val intent = Intent(Intent.ACTION_VIEW)
            intent.data = Uri.parse(viewModel.exploit.value?.exploitUrl())
            try {
                startActivity(Intent.createChooser(intent, item.title))
            } catch (_: ActivityNotFoundException) {
            }
            true
        }
        R.id.action_save -> {
            val intent = Intent(Intent.ACTION_VIEW)
            intent.data = Uri.parse(viewModel.exploit.value?.downloadUrl())
            try {
                startActivity(Intent.createChooser(intent, item.title))
            } catch (_: ActivityNotFoundException) {
            }
            true
        }
        R.id.action_share -> {
            viewModel.exploit.value?.let {
                ShareHelper(this).shareExploitLink(it)
            }
            true
        }
        else -> super.onOptionsItemSelected(item)
    }

    companion object {

        const val ACTION_EXPLOIT_VIEW = "${BuildConfig.APPLICATION_ID}.action.VIEW_EXPLOIT"

        fun newIntent(context: Context, exploit: Exploit): Intent {
            return Intent(context, DetailsActivity::class.java)
                .putExtra(ExploitIntent.KEY_EXPLOIT, exploit)
        }

        fun newIntent(context: Context, exploitId: Long): Intent {
            return Intent(context, DetailsActivity::class.java)
                .putExtra(ExploitIntent.KEY_ID, exploitId)
        }
    }
}