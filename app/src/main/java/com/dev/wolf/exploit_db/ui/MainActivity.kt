package com.dev.wolf.exploit_db.ui

import android.os.Bundle
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.core.graphics.Insets
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePadding
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentTransaction
import androidx.fragment.app.commit
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.base.BaseActivity
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.databinding.ActivityMainBinding
import com.dev.wolf.exploit_db.search.ui.SearchActivity
import com.dev.wolf.exploit_db.search.ui.suggestion.SearchSuggestionFragment
import com.dev.wolf.exploit_db.search.ui.suggestion.SearchSuggestionListener
import com.dev.wolf.exploit_db.search.ui.suggestion.SearchSuggestionViewModel
import com.dev.wolf.exploit_db.ui.detail.ui.DetailsActivity
import com.dev.wolf.exploit_db.ui.favourites.FavouritesListFragment
import com.dev.wolf.exploit_db.ui.list.fragment.RemoteListFragment
import com.dev.wolf.exploit_db.utils.ext.resolveDp
import com.google.android.material.navigation.NavigationBarView
import org.koin.androidx.viewmodel.ext.android.viewModel

class MainActivity : BaseActivity<ActivityMainBinding>(), View.OnFocusChangeListener,
    SearchSuggestionListener {

    private val searchSuggestionViewModel by viewModel<SearchSuggestionViewModel>(
        mode = LazyThreadSafetyMode.NONE
    )

    private var searchViewElevation = 0f
    private val nav: NavigationBarView
        get() = binding.bottomNav

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(ActivityMainBinding.inflate(layoutInflater))
        searchViewElevation = binding.toolbarCard.cardElevation
        supportActionBar?.setDisplayHomeAsUpEnabled(false)

        with(binding.searchView) {
            onFocusChangeListener = this@MainActivity
            searchSuggestionListener = this@MainActivity
        }
        nav.setOnItemSelectedListener { item ->
            when(item.itemId){
                R.id.nav_remote -> {
                    setPrimaryFragment(RemoteListFragment.newInstance())
                }
                R.id.nav_favorites -> {
                    setPrimaryFragment(FavouritesListFragment.newInstance())
                }
            }
            true
        }
        setPrimaryFragment(RemoteListFragment.newInstance())
    }

    override fun onWindowInsetsChanged(insets: Insets) {
        binding.toolbarCard.updateLayoutParams<ViewGroup.MarginLayoutParams> {
            topMargin = insets.top + resources.resolveDp(8)
            leftMargin = insets.left + resources.resolveDp(16)
            rightMargin = insets.right + resources.resolveDp(16)
        }
        binding.bottomNav.updatePadding(
            left = insets.left,
            right = insets.right,
            bottom = insets.bottom
        )
    }

    private fun setPrimaryFragment(fragment: Fragment) {
        supportFragmentManager.beginTransaction()
            .replace(R.id.container, fragment, TAG_PRIMARY)
            .commit()
        invalidateOptionsMenu()
    }

    override fun onBackPressed() {
        val fragment = supportFragmentManager.findFragmentByTag(TAG_SEARCH)
        binding.searchView.clearFocus()
        when {
            fragment != null -> supportFragmentManager.commit {
                remove(fragment)
                setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
                runOnCommit { onSearchClosed() }
            }
            else -> super.onBackPressed()
        }
    }

    override fun onFocusChange(v: View?, hasFocus: Boolean) {
        val fragment = supportFragmentManager.findFragmentByTag(TAG_SEARCH)
        if (v?.id == R.id.searchView && hasFocus) {
            if (fragment == null) {
                supportFragmentManager.commit {
                    add(R.id.container, SearchSuggestionFragment.newInstance(), TAG_SEARCH)
                    setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
                    runOnCommit { onSearchOpened() }
                }
            }
        }
    }

    override fun onExploitClick(exploit: Exploit) {
        startActivity(DetailsActivity.newIntent(this@MainActivity, exploit))
    }

    override fun onQueryClick(query: String, submit: Boolean) {
        binding.searchView.query = query
        if (submit) {
            if (query.isNotEmpty()) {
                startActivity(SearchActivity.newIntent(this, query))
                searchSuggestionViewModel.saveQuery(query)
            }
        }
    }

    override fun onQueryChanged(query: String) {
        searchSuggestionViewModel.onQueryChanged(query)
    }

    override fun onClearSearchHistory() {
        AlertDialog.Builder(this)
            .setTitle(R.string.clear_search_history)
            .setMessage(R.string.text_clear_search_history_prompt)
            .setNegativeButton(android.R.string.cancel, null)
            .setPositiveButton(R.string.clear) { _, _ ->
                searchSuggestionViewModel.clearSearchHistory()
            }.show()
    }

    private fun onSearchOpened() {
        binding.toolbarCard.cardElevation = 0f
        binding.appbar.elevation = searchViewElevation
    }

    private fun onSearchClosed() {
        binding.appbar.elevation = 0f
        binding.toolbarCard.cardElevation = searchViewElevation
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.opt_main, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean = when(item.itemId){
        R.id.action_remote -> {
            setPrimaryFragment(RemoteListFragment.newInstance())
            true
        }
        R.id.action_favorites -> {
            setPrimaryFragment(FavouritesListFragment.newInstance())
            true
        }
        else -> super.onOptionsItemSelected(item)
    }

    private companion object {
        const val TAG_PRIMARY = "primary"
        const val TAG_SEARCH = "search"
    }
}