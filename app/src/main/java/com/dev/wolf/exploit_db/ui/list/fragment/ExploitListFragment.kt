package com.dev.wolf.exploit_db.ui.list.fragment

import android.os.Bundle
import android.util.Log
import android.view.*
import androidx.annotation.CallSuper
import androidx.core.content.ContextCompat
import androidx.core.graphics.Insets
import androidx.core.view.GravityCompat
import androidx.core.view.isGone
import androidx.core.view.isVisible
import androidx.core.view.updatePadding
import androidx.drawerlayout.widget.DrawerLayout
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.RecyclerView
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
import com.dev.wolf.exploit_db.R
import com.dev.wolf.exploit_db.base.BaseFragment
import com.dev.wolf.exploit_db.base.list.OnListItemClickListener
import com.dev.wolf.exploit_db.base.list.PaginationScrollListener
import com.dev.wolf.exploit_db.base.list.decor.ItemTypeDividerDecoration
import com.dev.wolf.exploit_db.base.list.decor.SectionItemDecoration
import com.dev.wolf.exploit_db.core.model.Exploit
import com.dev.wolf.exploit_db.core.model.ExploitFilter
import com.dev.wolf.exploit_db.databinding.FragmentListBinding
import com.dev.wolf.exploit_db.ui.detail.ui.DetailsActivity
import com.dev.wolf.exploit_db.ui.list.ExploitFilterConfig
import com.dev.wolf.exploit_db.ui.list.ExploitListViewModel
import com.dev.wolf.exploit_db.ui.list.adapter.ExploitListAdapter
import com.dev.wolf.exploit_db.ui.list.filter.FilterAdapter
import com.dev.wolf.exploit_db.ui.list.filter.OnFilterChangedListener
import com.dev.wolf.exploit_db.ui.list.filter2.FiltersDialog
import com.dev.wolf.exploit_db.ui.list.model.ListModel
import com.dev.wolf.exploit_db.utils.RecycledViewPoolHolder
import com.dev.wolf.exploit_db.utils.ext.getDisplayMessage
import com.dev.wolf.exploit_db.utils.ext.toggleDrawer
import com.google.android.material.snackbar.Snackbar
import kotlinx.coroutines.launch
import org.koin.android.ext.android.get


abstract class ExploitListFragment : BaseFragment<FragmentListBinding>(),
    SwipeRefreshLayout.OnRefreshListener, PaginationScrollListener.Callback,
    OnListItemClickListener<Exploit>, OnFilterChangedListener {

    protected abstract val viewModel: ExploitListViewModel
    open val isSwipeRefreshEnabled = true
    private var listAdapter: ExploitListAdapter? = null
    private var paginationListener: PaginationScrollListener? = null
    private var filterConfig : ExploitFilterConfig? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }

    override fun onInflateView(
        inflater: LayoutInflater,
        container: ViewGroup?
    ) = FragmentListBinding.inflate(inflater, container, false)

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        listAdapter = ExploitListAdapter(this, ::resolveException)
        paginationListener = PaginationScrollListener(4, this)

        with(binding.recyclerView) {
            setHasFixedSize(true)
            adapter = listAdapter
            addOnScrollListener(paginationListener!!)
            addItemDecoration(
                DividerItemDecoration(
                    view.context,
                    RecyclerView.VERTICAL
                )
            )
        }
        with(binding.swipeRefreshLayout) {
            setColorSchemeColors(
                ContextCompat.getColor(context, R.color.color_primary),
                ContextCompat.getColor(context, R.color.color_primary_variant)
            )
            setOnRefreshListener(this@ExploitListFragment)
            isEnabled = isSwipeRefreshEnabled
        }

        (parentFragment as? RecycledViewPoolHolder)?.let {
            binding.recyclerView.setRecycledViewPool(it.recycledViewPool)
        }

        viewModel.content.observe(viewLifecycleOwner, ::onListChanged)
        viewModel.filter.observe(viewLifecycleOwner, ::onInitFilter)
        viewModel.onError.observe(viewLifecycleOwner, ::onError)
        viewModel.isLoading.observe(viewLifecycleOwner, ::onLoadingStateChanged)
    }

    override fun onDestroyView() {
        listAdapter = null
        paginationListener = null
        super.onDestroyView()
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.opt_list, menu)
        super.onCreateOptionsMenu(menu, inflater)
    }

    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
        R.id.action_filter -> {
            if (filterConfig != null){
                FiltersDialog
                    .show(
                    filterConfig?.currentFilter,
                    childFragmentManager,
                    this)
            }
            true
        }
        else -> super.onOptionsItemSelected(item)
    }

    override fun onWindowInsetsChanged(insets: Insets) {
        binding.recyclerView.updatePadding(
            bottom = insets.bottom
        )
        binding.root.updatePadding(
            left = insets.left,
            right = insets.right
        )
    }

    @CallSuper
    override fun onRefresh() {
        binding.swipeRefreshLayout.isRefreshing = true
        viewModel.onRefresh()
    }

    private fun onListChanged(list: List<ListModel>) {
        listAdapter?.setItems2(list)
    }

    private fun onInitFilter(config: ExploitFilterConfig) {
        filterConfig = config
        activity?.invalidateOptionsMenu()
    }

    @CallSuper
    override fun onFilterChanged(filter: ExploitFilter) {
        Log.d("ExploitListFragment", "onFilterChanged : $filter")
    }

    override fun onItemClick(item: Exploit, view: View) {
        startActivity(DetailsActivity.newIntent(context ?: return, item))
    }

    private fun onError(e: Throwable) {
        Snackbar.make(
            binding.recyclerView,
            e.getDisplayMessage(resources),
            Snackbar.LENGTH_SHORT
        ).show()
    }

    private fun resolveException(e: Throwable) {
        viewModel.onRetry()
    }

    @CallSuper
    protected open fun onLoadingStateChanged(isLoading: Boolean) {
        binding.swipeRefreshLayout.isEnabled = binding.swipeRefreshLayout.isRefreshing ||
                isSwipeRefreshEnabled && !isLoading
        if (!isLoading) {
            binding.swipeRefreshLayout.isRefreshing = false
        }
    }

}